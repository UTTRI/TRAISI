/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.8.1.0 (NJsonSchema v10.2.0.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';
import { SurveyRespondentViewModel, SurveyViewerValidationStateViewModel, SurveyResponseViewModel, SurveyLogicCondition, SurveyLogicOperator, SurveyViewerLogicRulesViewModel } from 'traisi-question-sdk';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable({
    providedIn: 'root'
})
export class SurveyRespondentClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getSurveyPrimaryRespondent(surveyId: number): Observable<SurveyRespondentViewModel> {
        let url_ = this.baseUrl + "/api/SurveyRespondent/surveys/{surveyId}/respondents/primary";
        if (surveyId === undefined || surveyId === null)
            throw new Error("The parameter 'surveyId' must be defined.");
        url_ = url_.replace("{surveyId}", encodeURIComponent("" + surveyId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSurveyPrimaryRespondent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSurveyPrimaryRespondent(<any>response_);
                } catch (e) {
                    return <Observable<SurveyRespondentViewModel>><any>_observableThrow(e); 
                }
            } else
                return <Observable<SurveyRespondentViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetSurveyPrimaryRespondent(response: HttpResponseBase): Observable<SurveyRespondentViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SurveyRespondentViewModel>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SurveyRespondentViewModel>(<any>null);
    }

    addSurveyGroupMember(respondent: SurveyRespondentViewModel | null): Observable<number> {
        let url_ = this.baseUrl + "/api/SurveyRespondent/respondents/groups";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(respondent);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddSurveyGroupMember(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddSurveyGroupMember(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processAddSurveyGroupMember(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <number>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    updateSurveyGroupMember(respondent: SurveyRespondentViewModel | null): Observable<void> {
        let url_ = this.baseUrl + "/api/SurveyRespondent/respondents/groups";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(respondent);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSurveyGroupMember(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSurveyGroupMember(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateSurveyGroupMember(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    removeSurveyGroupMember(respondentId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/SurveyRespondent/groups/respondents/{respondentId}";
        if (respondentId === undefined || respondentId === null)
            throw new Error("The parameter 'respondentId' must be defined.");
        url_ = url_.replace("{respondentId}", encodeURIComponent("" + respondentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveSurveyGroupMember(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveSurveyGroupMember(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveSurveyGroupMember(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    listSurveyGroupMembers(respondentId: number): Observable<SurveyRespondentViewModel[]> {
        let url_ = this.baseUrl + "/api/SurveyRespondent/groups/respondents/{respondentId}";
        if (respondentId === undefined || respondentId === null)
            throw new Error("The parameter 'respondentId' must be defined.");
        url_ = url_.replace("{respondentId}", encodeURIComponent("" + respondentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListSurveyGroupMembers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListSurveyGroupMembers(<any>response_);
                } catch (e) {
                    return <Observable<SurveyRespondentViewModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SurveyRespondentViewModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processListSurveyGroupMembers(response: HttpResponseBase): Observable<SurveyRespondentViewModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SurveyRespondentViewModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SurveyRespondentViewModel[]>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class SurveyResponseClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    saveResponse(surveyId: number, questionId: number, respondentId: number, repeat: number, language: string | null | undefined, force: boolean | undefined, isPartial: boolean | undefined, content: any[] | null): Observable<SurveyViewerValidationStateViewModel> {
        let url_ = this.baseUrl + "/api/SurveyResponse/surveys/{surveyId}/questions/{questionId}/respondents/{respondentId}/{repeat}?";
        if (surveyId === undefined || surveyId === null)
            throw new Error("The parameter 'surveyId' must be defined.");
        url_ = url_.replace("{surveyId}", encodeURIComponent("" + surveyId));
        if (questionId === undefined || questionId === null)
            throw new Error("The parameter 'questionId' must be defined.");
        url_ = url_.replace("{questionId}", encodeURIComponent("" + questionId));
        if (respondentId === undefined || respondentId === null)
            throw new Error("The parameter 'respondentId' must be defined.");
        url_ = url_.replace("{respondentId}", encodeURIComponent("" + respondentId));
        if (repeat === undefined || repeat === null)
            throw new Error("The parameter 'repeat' must be defined.");
        url_ = url_.replace("{repeat}", encodeURIComponent("" + repeat));
        if (force === null)
            throw new Error("The parameter 'force' cannot be null.");
        else if (force !== undefined)
            url_ += "force=" + encodeURIComponent("" + force) + "&";
        if (isPartial === null)
            throw new Error("The parameter 'isPartial' cannot be null.");
        else if (isPartial !== undefined)
            url_ += "isPartial=" + encodeURIComponent("" + isPartial) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(content);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "language": language !== undefined && language !== null ? "" + language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveResponse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveResponse(<any>response_);
                } catch (e) {
                    return <Observable<SurveyViewerValidationStateViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<SurveyViewerValidationStateViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processSaveResponse(response: HttpResponseBase): Observable<SurveyViewerValidationStateViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SurveyViewerValidationStateViewModel>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SurveyViewerValidationStateViewModel>(<any>null);
    }

    getResponse(surveyId: number, questionId: number, respondentId: number, repeat: number): Observable<SurveyResponseViewModel> {
        let url_ = this.baseUrl + "/api/SurveyResponse/surveys/{surveyId}/questions/{questionId}/respondents/{respondentId}/{repeat}";
        if (surveyId === undefined || surveyId === null)
            throw new Error("The parameter 'surveyId' must be defined.");
        url_ = url_.replace("{surveyId}", encodeURIComponent("" + surveyId));
        if (questionId === undefined || questionId === null)
            throw new Error("The parameter 'questionId' must be defined.");
        url_ = url_.replace("{questionId}", encodeURIComponent("" + questionId));
        if (respondentId === undefined || respondentId === null)
            throw new Error("The parameter 'respondentId' must be defined.");
        url_ = url_.replace("{respondentId}", encodeURIComponent("" + respondentId));
        if (repeat === undefined || repeat === null)
            throw new Error("The parameter 'repeat' must be defined.");
        url_ = url_.replace("{repeat}", encodeURIComponent("" + repeat));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetResponse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetResponse(<any>response_);
                } catch (e) {
                    return <Observable<SurveyResponseViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<SurveyResponseViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetResponse(response: HttpResponseBase): Observable<SurveyResponseViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SurveyResponseViewModel>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SurveyResponseViewModel>(<any>null);
    }

    excludeResponses(surveyId: number, respondentId: number, shouldExclude: boolean, questionIds: number[] | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/SurveyResponse/surveys/{surveyId}/questions/respondents/{respondentId}/exclude/{shouldExclude}?";
        if (surveyId === undefined || surveyId === null)
            throw new Error("The parameter 'surveyId' must be defined.");
        url_ = url_.replace("{surveyId}", encodeURIComponent("" + surveyId));
        if (respondentId === undefined || respondentId === null)
            throw new Error("The parameter 'respondentId' must be defined.");
        url_ = url_.replace("{respondentId}", encodeURIComponent("" + respondentId));
        if (shouldExclude === undefined || shouldExclude === null)
            throw new Error("The parameter 'shouldExclude' must be defined.");
        url_ = url_.replace("{shouldExclude}", encodeURIComponent("" + shouldExclude));
        if (questionIds !== undefined && questionIds !== null)
            questionIds && questionIds.forEach(item => { url_ += "questionIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExcludeResponses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExcludeResponses(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processExcludeResponses(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    listResponsesOfType(surveyId: number, responseType: QuestionResponseType): Observable<SurveyResponseViewModel[]> {
        let url_ = this.baseUrl + "/api/SurveyResponse/surveys/{surveyId}/responses/types/{responseType}";
        if (surveyId === undefined || surveyId === null)
            throw new Error("The parameter 'surveyId' must be defined.");
        url_ = url_.replace("{surveyId}", encodeURIComponent("" + surveyId));
        if (responseType === undefined || responseType === null)
            throw new Error("The parameter 'responseType' must be defined.");
        url_ = url_.replace("{responseType}", encodeURIComponent("" + responseType));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListResponsesOfType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListResponsesOfType(<any>response_);
                } catch (e) {
                    return <Observable<SurveyResponseViewModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SurveyResponseViewModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processListResponsesOfType(response: HttpResponseBase): Observable<SurveyResponseViewModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SurveyResponseViewModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SurveyResponseViewModel[]>(<any>null);
    }

    listSurveyResponsesForQuestions(surveyId: number | undefined, questionIds: number[] | null | undefined, respondentId: number): Observable<SurveyResponseViewModel[]> {
        let url_ = this.baseUrl + "/api/SurveyResponse/questions/respondents/{respondentId}/responses?";
        if (respondentId === undefined || respondentId === null)
            throw new Error("The parameter 'respondentId' must be defined.");
        url_ = url_.replace("{respondentId}", encodeURIComponent("" + respondentId));
        if (questionIds !== undefined && questionIds !== null)
            questionIds && questionIds.forEach(item => { url_ += "questionIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "surveyId": surveyId !== undefined && surveyId !== null ? "" + surveyId : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListSurveyResponsesForQuestions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListSurveyResponsesForQuestions(<any>response_);
                } catch (e) {
                    return <Observable<SurveyResponseViewModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SurveyResponseViewModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processListSurveyResponsesForQuestions(response: HttpResponseBase): Observable<SurveyResponseViewModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SurveyResponseViewModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SurveyResponseViewModel[]>(<any>null);
    }

    listSurveyResponsesForQuestionsForMultipleRespondents(surveyId: number | undefined, questionIds: number[] | null | undefined, respondentIds: number[] | null | undefined): Observable<SurveyResponseViewModel[]> {
        let url_ = this.baseUrl + "/api/SurveyResponse/questions/respondents/responses?";
        if (questionIds !== undefined && questionIds !== null)
            questionIds && questionIds.forEach(item => { url_ += "questionIds=" + encodeURIComponent("" + item) + "&"; });
        if (respondentIds !== undefined && respondentIds !== null)
            respondentIds && respondentIds.forEach(item => { url_ += "respondentIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "surveyId": surveyId !== undefined && surveyId !== null ? "" + surveyId : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListSurveyResponsesForQuestionsForMultipleRespondents(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListSurveyResponsesForQuestionsForMultipleRespondents(<any>response_);
                } catch (e) {
                    return <Observable<SurveyResponseViewModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SurveyResponseViewModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processListSurveyResponsesForQuestionsForMultipleRespondents(response: HttpResponseBase): Observable<SurveyResponseViewModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SurveyResponseViewModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SurveyResponseViewModel[]>(<any>null);
    }

    listSurveyResponsesForQuestionsByName(surveyId: number | undefined, questionNames: string[] | null | undefined, respondentId: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/SurveyResponse/questions/names/respondents/{respondentId}/responses?";
        if (respondentId === undefined || respondentId === null)
            throw new Error("The parameter 'respondentId' must be defined.");
        url_ = url_.replace("{respondentId}", encodeURIComponent("" + respondentId));
        if (questionNames !== undefined && questionNames !== null)
            questionNames && questionNames.forEach(item => { url_ += "questionNames=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "surveyId": surveyId !== undefined && surveyId !== null ? "" + surveyId : "",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListSurveyResponsesForQuestionsByName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListSurveyResponsesForQuestionsByName(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processListSurveyResponsesForQuestionsByName(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getSurveyCompletionStatus(surveyId: number, respondentId: number): Observable<SurveyCompletionStatus> {
        let url_ = this.baseUrl + "/api/SurveyResponse/completion-status/primary-respondents/{respondentId}?";
        if (respondentId === undefined || respondentId === null)
            throw new Error("The parameter 'respondentId' must be defined.");
        url_ = url_.replace("{respondentId}", encodeURIComponent("" + respondentId));
        if (surveyId === undefined || surveyId === null)
            throw new Error("The parameter 'surveyId' must be defined and cannot be null.");
        else
            url_ += "surveyId=" + encodeURIComponent("" + surveyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSurveyCompletionStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSurveyCompletionStatus(<any>response_);
                } catch (e) {
                    return <Observable<SurveyCompletionStatus>><any>_observableThrow(e);
                }
            } else
                return <Observable<SurveyCompletionStatus>><any>_observableThrow(response_);
        }));
    }

    protected processGetSurveyCompletionStatus(response: HttpResponseBase): Observable<SurveyCompletionStatus> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SurveyCompletionStatus>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SurveyCompletionStatus>(<any>null);
    }

    deleteAllResponses(surveyId: number, respondentId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/SurveyResponse/surveys/{surveyId}/respondents/{respondentId}";
        if (surveyId === undefined || surveyId === null)
            throw new Error("The parameter 'surveyId' must be defined.");
        url_ = url_.replace("{surveyId}", encodeURIComponent("" + surveyId));
        if (respondentId === undefined || respondentId === null)
            throw new Error("The parameter 'respondentId' must be defined.");
        url_ = url_.replace("{respondentId}", encodeURIComponent("" + respondentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAllResponses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAllResponses(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteAllResponses(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class SurveyViewerClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getSurveyViews(surveyId: number): Observable<SurveyView[]> {
        let url_ = this.baseUrl + "/api/SurveyViewer/views/{surveyId}";
        if (surveyId === undefined || surveyId === null)
            throw new Error("The parameter 'surveyId' must be defined.");
        url_ = url_.replace("{surveyId}", encodeURIComponent("" + surveyId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSurveyViews(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSurveyViews(<any>response_);
                } catch (e) {
                    return <Observable<SurveyView[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SurveyView[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSurveyViews(response: HttpResponseBase): Observable<SurveyView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SurveyView[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SurveyView[]>(<any>null);
    }

    getSurveyFromCode(code: string | null): Observable<number> {
        let url_ = this.baseUrl + "/api/SurveyViewer/codes/{code}";
        if (code === undefined || code === null)
            throw new Error("The parameter 'code' must be defined.");
        url_ = url_.replace("{code}", encodeURIComponent("" + code));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSurveyFromCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSurveyFromCode(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetSurveyFromCode(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <number>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    getSurveyViewQuestions(viewId: number): Observable<SurveyView[]> {
        let url_ = this.baseUrl + "/api/SurveyViewer/questions/{viewId}";
        if (viewId === undefined || viewId === null)
            throw new Error("The parameter 'viewId' must be defined.");
        url_ = url_.replace("{viewId}", encodeURIComponent("" + viewId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSurveyViewQuestions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSurveyViewQuestions(<any>response_);
                } catch (e) {
                    return <Observable<SurveyView[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SurveyView[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSurveyViewQuestions(response: HttpResponseBase): Observable<SurveyView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SurveyView[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SurveyView[]>(<any>null);
    }

    getSurveyViewPages(surveyId: number, viewType: SurveyViewType | undefined, language: string | null | undefined): Observable<SurveyViewPageViewModel[]> {
        let url_ = this.baseUrl + "/api/SurveyViewer/surveys/{surveyId}?";
        if (surveyId === undefined || surveyId === null)
            throw new Error("The parameter 'surveyId' must be defined.");
        url_ = url_.replace("{surveyId}", encodeURIComponent("" + surveyId));
        if (viewType === null)
            throw new Error("The parameter 'viewType' cannot be null.");
        else if (viewType !== undefined)
            url_ += "viewType=" + encodeURIComponent("" + viewType) + "&";
        if (language !== undefined && language !== null)
            url_ += "language=" + encodeURIComponent("" + language) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSurveyViewPages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSurveyViewPages(<any>response_);
                } catch (e) {
                    return <Observable<SurveyViewPageViewModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SurveyViewPageViewModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSurveyViewPages(response: HttpResponseBase): Observable<SurveyViewPageViewModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SurveyViewPageViewModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SurveyViewPageViewModel[]>(<any>null);
    }

    getSurveyViewQuestionConfiguration(questionId: number): Observable<QuestionConfiguration> {
        let url_ = this.baseUrl + "/api/SurveyViewer/configurations/{questionId}";
        if (questionId === undefined || questionId === null)
            throw new Error("The parameter 'questionId' must be defined.");
        url_ = url_.replace("{questionId}", encodeURIComponent("" + questionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSurveyViewQuestionConfiguration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSurveyViewQuestionConfiguration(<any>response_);
                } catch (e) {
                    return <Observable<QuestionConfiguration>><any>_observableThrow(e);
                }
            } else
                return <Observable<QuestionConfiguration>><any>_observableThrow(response_);
        }));
    }

    protected processGetSurveyViewQuestionConfiguration(response: HttpResponseBase): Observable<QuestionConfiguration> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <QuestionConfiguration>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QuestionConfiguration>(<any>null);
    }

    getQuestionOptions(surveyId: number, questionId: number, query: string | null | undefined, language: string | null | undefined): Observable<QuestionOptionsViewModel[]> {
        let url_ = this.baseUrl + "/api/SurveyViewer/surveys/{surveyId}/questions/{questionId}/options?";
        if (surveyId === undefined || surveyId === null)
            throw new Error("The parameter 'surveyId' must be defined.");
        url_ = url_.replace("{surveyId}", encodeURIComponent("" + surveyId));
        if (questionId === undefined || questionId === null)
            throw new Error("The parameter 'questionId' must be defined.");
        url_ = url_.replace("{questionId}", encodeURIComponent("" + questionId));
        if (query !== undefined && query !== null)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        if (language !== undefined && language !== null)
            url_ += "language=" + encodeURIComponent("" + language) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetQuestionOptions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetQuestionOptions(<any>response_);
                } catch (e) {
                    return <Observable<QuestionOptionsViewModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<QuestionOptionsViewModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetQuestionOptions(response: HttpResponseBase): Observable<QuestionOptionsViewModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <QuestionOptionsViewModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QuestionOptionsViewModel[]>(<any>null);
    }

    getDefaultSurveyView(surveyId: number, language: string | null | undefined): Observable<SurveyViewerViewModel> {
        let url_ = this.baseUrl + "/api/SurveyViewer/view/{surveyId}?";
        if (surveyId === undefined || surveyId === null)
            throw new Error("The parameter 'surveyId' must be defined.");
        url_ = url_.replace("{surveyId}", encodeURIComponent("" + surveyId));
        if (language !== undefined && language !== null)
            url_ += "language=" + encodeURIComponent("" + language) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDefaultSurveyView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDefaultSurveyView(<any>response_);
                } catch (e) {
                    return <Observable<SurveyViewerViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<SurveyViewerViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetDefaultSurveyView(response: HttpResponseBase): Observable<SurveyViewerViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SurveyViewerViewModel>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SurveyViewerViewModel>(<any>null);
    }

    getSurveyStyles(surveyId: number): Observable<string> {
        let url_ = this.baseUrl + "/api/SurveyViewer/styles/{surveyId}";
        if (surveyId === undefined || surveyId === null)
            throw new Error("The parameter 'surveyId' must be defined.");
        url_ = url_.replace("{surveyId}", encodeURIComponent("" + surveyId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSurveyStyles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSurveyStyles(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetSurveyStyles(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <string>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    startSurvey(surveyId: number, shortcode: string | null): Observable<boolean> {
        let url_ = this.baseUrl + "/api/SurveyViewer/start/{surveyId}/{shortcode}";
        if (surveyId === undefined || surveyId === null)
            throw new Error("The parameter 'surveyId' must be defined.");
        url_ = url_.replace("{surveyId}", encodeURIComponent("" + surveyId));
        if (shortcode === undefined || shortcode === null)
            throw new Error("The parameter 'shortcode' must be defined.");
        url_ = url_.replace("{shortcode}", encodeURIComponent("" + shortcode));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStartSurvey(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStartSurvey(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processStartSurvey(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    startSurveyWithGroupcode(surveyId: number, groupcode: string | null, user_Agent: string | null | undefined, queryParams: any | null): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/SurveyViewer/start/{surveyId}/groupcode/{groupcode}";
        if (surveyId === undefined || surveyId === null)
            throw new Error("The parameter 'surveyId' must be defined.");
        url_ = url_.replace("{surveyId}", encodeURIComponent("" + surveyId));
        if (groupcode === undefined || groupcode === null)
            throw new Error("The parameter 'groupcode' must be defined.");
        url_ = url_.replace("{groupcode}", encodeURIComponent("" + groupcode));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(queryParams);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "User-Agent": user_Agent !== undefined && user_Agent !== null ? "" + user_Agent : "",
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStartSurveyWithGroupcode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStartSurveyWithGroupcode(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processStartSurveyWithGroupcode(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getSurveyWelcomeView(name: string | null): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/SurveyViewer/welcome/{name}";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSurveyWelcomeView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSurveyWelcomeView(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetSurveyWelcomeView(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    validateSurveyGroupcode(surveyId: number, groupcode: string | null): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/SurveyViewer/surveys/{surveyId}/groupcodes/{groupcode}/validate";
        if (surveyId === undefined || surveyId === null)
            throw new Error("The parameter 'surveyId' must be defined.");
        url_ = url_.replace("{surveyId}", encodeURIComponent("" + surveyId));
        if (groupcode === undefined || groupcode === null)
            throw new Error("The parameter 'groupcode' must be defined.");
        url_ = url_.replace("{groupcode}", encodeURIComponent("" + groupcode));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidateSurveyGroupcode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateSurveyGroupcode(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processValidateSurveyGroupcode(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getRespondentSurveyViewPageQuestions(surveyId: number, pageNumber: number, language: string | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/SurveyViewer/viewer/{surveyId}/page/{pageNumber}?";
        if (surveyId === undefined || surveyId === null)
            throw new Error("The parameter 'surveyId' must be defined.");
        url_ = url_.replace("{surveyId}", encodeURIComponent("" + surveyId));
        if (pageNumber === undefined || pageNumber === null)
            throw new Error("The parameter 'pageNumber' must be defined.");
        url_ = url_.replace("{pageNumber}", encodeURIComponent("" + pageNumber));
        if (language !== undefined && language !== null)
            url_ += "language=" + encodeURIComponent("" + language) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRespondentSurveyViewPageQuestions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRespondentSurveyViewPageQuestions(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetRespondentSurveyViewPageQuestions(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getSurveyViewPageQuestions(surveyId: number, pageNumber: number, viewType: SurveyViewType, language: string | null): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/SurveyViewer/{surveyId}/page/{pageNumber}/{viewType}/{language}";
        if (surveyId === undefined || surveyId === null)
            throw new Error("The parameter 'surveyId' must be defined.");
        url_ = url_.replace("{surveyId}", encodeURIComponent("" + surveyId));
        if (pageNumber === undefined || pageNumber === null)
            throw new Error("The parameter 'pageNumber' must be defined.");
        url_ = url_.replace("{pageNumber}", encodeURIComponent("" + pageNumber));
        if (viewType === undefined || viewType === null)
            throw new Error("The parameter 'viewType' must be defined.");
        url_ = url_.replace("{viewType}", encodeURIComponent("" + viewType));
        if (language === undefined || language === null)
            throw new Error("The parameter 'language' must be defined.");
        url_ = url_.replace("{language}", encodeURIComponent("" + language));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSurveyViewPageQuestions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSurveyViewPageQuestions(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetSurveyViewPageQuestions(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getSurveyTermsAndConditions(surveyId: number, viewType: SurveyViewType, language: string | null): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/SurveyViewer/{surveyId}/terms/{viewType}/{language}";
        if (surveyId === undefined || surveyId === null)
            throw new Error("The parameter 'surveyId' must be defined.");
        url_ = url_.replace("{surveyId}", encodeURIComponent("" + surveyId));
        if (viewType === undefined || viewType === null)
            throw new Error("The parameter 'viewType' must be defined.");
        url_ = url_.replace("{viewType}", encodeURIComponent("" + viewType));
        if (language === undefined || language === null)
            throw new Error("The parameter 'language' must be defined.");
        url_ = url_.replace("{language}", encodeURIComponent("" + language));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSurveyTermsAndConditions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSurveyTermsAndConditions(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetSurveyTermsAndConditions(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getSurveyScreeningQuestions(surveyId: number, language: string | null): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/SurveyViewer/{surveyId}/screening/{language}";
        if (surveyId === undefined || surveyId === null)
            throw new Error("The parameter 'surveyId' must be defined.");
        url_ = url_.replace("{surveyId}", encodeURIComponent("" + surveyId));
        if (language === undefined || language === null)
            throw new Error("The parameter 'language' must be defined.");
        url_ = url_.replace("{language}", encodeURIComponent("" + language));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSurveyScreeningQuestions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSurveyScreeningQuestions(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetSurveyScreeningQuestions(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getSurveyThankYou(surveyId: number, viewType: SurveyViewType, language: string | null): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/SurveyViewer/{surveyId}/thankyou/{viewType}/{language}";
        if (surveyId === undefined || surveyId === null)
            throw new Error("The parameter 'surveyId' must be defined.");
        url_ = url_.replace("{surveyId}", encodeURIComponent("" + surveyId));
        if (viewType === undefined || viewType === null)
            throw new Error("The parameter 'viewType' must be defined.");
        url_ = url_.replace("{viewType}", encodeURIComponent("" + viewType));
        if (language === undefined || language === null)
            throw new Error("The parameter 'language' must be defined.");
        url_ = url_.replace("{language}", encodeURIComponent("" + language));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSurveyThankYou(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSurveyThankYou(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetSurveyThankYou(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    surveyComplete(surveyId: number, shortcode: string | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/SurveyViewer/complete/{surveyId}";
        if (surveyId === undefined || surveyId === null)
            throw new Error("The parameter 'surveyId' must be defined.");
        url_ = url_.replace("{surveyId}", encodeURIComponent("" + surveyId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Shortcode": shortcode !== undefined && shortcode !== null ? "" + shortcode : "",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSurveyComplete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSurveyComplete(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processSurveyComplete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

export interface Address {
    postalCode?: string | undefined;
    streetAddress?: string | undefined;
    streetNumber?: number;
    city?: string | undefined;
    province?: string | undefined;
    formattedAddress?: string | undefined;
    id?: string | undefined;
}

export enum ValidationState {
    Invalid = 0,
    Valid = 1,
    Untouched = 2,
    Touched = 3,
}

export enum QuestionResponseType {
    String = 0,
    Boolean = 1,
    Number = 2,
    Location = 3,
    Json = 4,
    OptionSelect = 5,
    DateTime = 6,
    Time = 7,
    Path = 8,
    Timeline = 9,
    None = 10,
}

export interface SurveyCompletionStatus {
    completedQuestionIds?: number[] | undefined;
}

export interface SurveyView {
    survey?: Survey | undefined;
    questionPartViews?: QuestionPartView[] | undefined;
    welcomePageLabels?: LabelCollectionOfLabel | undefined;
    termsAndConditionsLabels?: LabelCollectionOfLabel | undefined;
    thankYouPageLabels?: LabelCollectionOfLabel | undefined;
    screeningQuestionLabels?: LabelCollectionOfLabel | undefined;
    viewName?: string | undefined;
}

export interface AuditableEntity {
}

export interface Survey extends AuditableEntity {
    code?: string | undefined;
    name?: string | undefined;
    owner?: string | undefined;
    group?: string | undefined;
    startAt?: Date;
    endAt?: Date;
    isActive?: boolean;
    isOpen?: boolean;
    successLink?: string | undefined;
    rejectionLink?: string | undefined;
    defaultLanguage?: string | undefined;
    styleTemplate?: string | undefined;
    surveyViews?: SurveyViewCollectionOfSurveyView | undefined;
    surveyPermissions?: SurveyPermission[] | undefined;
    groupCodes?: Groupcode[] | undefined;
    shortcodes?: Shortcode[] | undefined;
    extensionConfigurations?: ExtensionConfiguration[] | undefined;
    titleLabels?: LabelCollectionOfLabel | undefined;
    surveyLogic?: SurveyLogic[] | undefined;
    hasGroupCodes?: boolean;
}

export interface Anonymous {
    Item?: SurveyView | undefined;
}

export interface SurveyViewCollectionOfSurveyView extends Anonymous {
}

export interface SurveyPermission {
    id?: number;
    userId?: string | undefined;
    user?: ApplicationUser | undefined;
    surveyId?: number;
    survey?: Survey | undefined;
    permissionCode?: string | undefined;
    permissions?: string[] | undefined;
}

export interface IdentityUserOfString {
    id?: string | undefined;
    userName?: string | undefined;
    normalizedUserName?: string | undefined;
    email?: string | undefined;
    normalizedEmail?: string | undefined;
    emailConfirmed?: boolean;
    passwordHash?: string | undefined;
    securityStamp?: string | undefined;
    concurrencyStamp?: string | undefined;
    phoneNumber?: string | undefined;
    phoneNumberConfirmed?: boolean;
    twoFactorEnabled?: boolean;
    lockoutEnd?: Date | undefined;
    lockoutEnabled?: boolean;
    accessFailedCount?: number;
}

export interface IdentityUser extends IdentityUserOfString {
}

export interface ApplicationUser extends IdentityUser {
    friendlyName?: string | undefined;
    jobTitle?: string | undefined;
    fullName?: string | undefined;
    configuration?: string | undefined;
    isEnabled?: boolean;
    isLockedOut?: boolean;
    createdBy?: string | undefined;
    updatedBy?: string | undefined;
    createdDate?: Date;
    updatedDate?: Date;
    roles?: IdentityUserRoleOfString[] | undefined;
    claims?: IdentityUserClaimOfString[] | undefined;
}

export interface IdentityUserRoleOfString {
    userId?: string | undefined;
    roleId?: string | undefined;
}

export interface IdentityUserClaimOfString {
    id?: number;
    userId?: string | undefined;
    claimType?: string | undefined;
    claimValue?: string | undefined;
}

export interface Groupcode {
    id?: number;
    survey?: Survey | undefined;
    name?: string | undefined;
    code?: string | undefined;
    createdDate?: Date;
    isTest?: boolean;
}

export interface Shortcode {
    id?: number;
    survey?: Survey | undefined;
    groupcode?: Groupcode | undefined;
    code?: string | undefined;
    isTest?: boolean;
    createdDate?: Date;
    surveyCompleted?: boolean;
}

export interface ExtensionConfiguration {
    survey?: Survey | undefined;
    extensionName: string;
    configuration: string;
}

export interface Anonymous2 {
    Item?: Label | undefined;
    Default?: Label | undefined;
}

export interface LabelCollectionOfLabel extends Anonymous2 {
}

export interface Label {
    value?: string | undefined;
    language?: string | undefined;
}

export interface SurveyLogic {
    condition?: SurveyLogicCondition | undefined;
    expressions?: SurveyLogic[] | undefined;
    validationMessages?: LabelCollectionOfLabel | undefined;
    value?: string | undefined;
    question?: QuestionPart | undefined;
    validationQuestionId?: number | undefined;
    validationQuestion?: QuestionPart | undefined;
    parentId?: number | undefined;
    parent?: SurveyLogic | undefined;
    root?: SurveyLogic | undefined;
    operator?: SurveyLogicOperator | undefined;
    logicType?: SurveyLogicType | undefined;
}

export interface QuestionPart {
    questionType?: string | undefined;
    name?: string | undefined;
    questionPartChildren?: QuestionPart[] | undefined;
    questionConfigurations?: QuestionConfiguration[] | undefined;
    questionOptions?: QuestionOption[] | undefined;
    questionOptionConditionalsSource?: QuestionOptionConditional[] | undefined;
    isGroupQuestion?: boolean;
    conditionals?: SurveyLogic[] | undefined;
    survey?: Survey | undefined;
}

export interface QuestionConfiguration {
    name?: string | undefined;
    value?: string | undefined;
    isResourceOnly?: boolean;
    valueType?: ConfigurationValueType;
    questionConfigurationLabels?: LabelCollectionOfLabel | undefined;
    isSourceInputRequired?: boolean;
}

export enum ConfigurationValueType {
    String = 0,
    Integer = 1,
    Decimal = 2,
    Boolean = 3,
    Tuple = 4,
    Time = 5,
    Date = 6,
    Custom = 7,
    Label = 8,
    Question = 9,
    KeyValuePair = 10,
    Response = 11,
}

export interface QuestionOption {
    name?: string | undefined;
    code?: string | undefined;
    questionOptionLabels?: LabelCollectionOfLabel | undefined;
    order?: number;
    questionOptionConditionalsTarget?: QuestionOptionConditional[] | undefined;
    questionPartParent?: QuestionPart | undefined;
}

export interface QuestionOptionConditional {
    targetOption?: QuestionOption | undefined;
    sourceQuestion?: QuestionPart | undefined;
    condition?: QuestionConditionalType;
    value?: string | undefined;
}

export enum QuestionConditionalType {
    IsEqualTo = 0,
    IsNotEqualTo = 1,
    GreaterThan = 2,
    LessThan = 3,
    InBounds = 4,
    OutOfBounds = 5,
    InRange = 6,
    OutsideRange = 7,
    IsAnyOf = 8,
    IsAllOf = 9,
    Contains = 10,
    DoesNotContain = 11,
}

export enum SurveyLogicType {
    Response = 0,
    Value = 1,
}

export interface QuestionPartView {
    labels?: LabelCollectionOfLabel | undefined;
    descriptionLabels?: LabelCollectionOfLabel | undefined;
    questionPart?: QuestionPart | undefined;
    parentView?: QuestionPartView | undefined;
    surveyView?: SurveyView | undefined;
    questionPartViewChildren?: QuestionPartView[] | undefined;
    order?: number;
    isOptional?: boolean;
    isHousehold?: boolean;
    isMultiView?: boolean;
    isDefaultHidden?: boolean;
    repeatSource?: QuestionPart | undefined;
    icon?: string | undefined;
    catiDependent?: QuestionPartView | undefined;
}

export interface SurveyViewPageViewModel {
    id?: number;
    sections?: SurveyViewSectionViewModel[] | undefined;
    questions?: QuestionViewModel[] | undefined;
    order?: number;
    label?: string | undefined;
    icon?: string | undefined;
}

export interface SurveyViewSectionViewModel {
    id?: number;
    order?: number;
    questions?: QuestionViewModel[] | undefined;
    label?: string | undefined;
    descriptionLabel?: string | undefined;
    icon?: string | undefined;
    isHousehold?: boolean;
    repeatSource?: number;
    isRepeat?: boolean;
    isMultiView?: boolean;
}

export interface QuestionViewModel {
    id?: number;
    questionId?: number;
    name?: string | undefined;
    label?: string | undefined;
    descriptionLabel?: string | undefined;
    questionType?: string | undefined;
    isOptional?: boolean;
    isRepeat?: boolean;
    repeatSource?: number;
    order?: number;
    isHousehold?: boolean;
    isMultiView?: boolean;
    configuration?: { [key: string]: any; } | undefined;
    conditionals?: SurveyViewerLogicRulesViewModel[] | undefined;
}

export interface SurveyLogicBaseViewModel {
}

export enum SurveyViewType {
    RespondentView = 0,
    CatiView = 1,
}

export interface QuestionOptionsViewModel {
}

export interface SurveyViewerViewModel {
    questions?: QuestionPartViewViewModel[] | undefined;
    id?: number;
    viewName?: string | undefined;
    survey?: SurveyViewModel | undefined;
    titleText?: string | undefined;
    termsAndConditionsText?: string | undefined;
    welcomeText?: string | undefined;
    surveyCompletionText?: string | undefined;
    screeningQuestions?: string[] | undefined;
}

export interface QuestionPartViewViewModel {
    questionChildren?: QuestionPartViewViewModel[] | undefined;
    id?: number;
    label?: string | undefined;
    descriptionLabel?: string | undefined;
    order?: number;
    questionType?: string | undefined;
}

export interface SurveyViewModel {
    id?: number;
    code?: string | undefined;
    name?: string | undefined;
    owner?: string | undefined;
    group?: string | undefined;
    createdDate?: Date;
    updatedDate?: Date;
    startAt?: Date;
    endAt?: Date;
    isActive?: boolean;
    isOpen?: boolean;
    successLink?: string | undefined;
    rejectionLink?: string | undefined;
    defaultLanguage?: string | undefined;
    styleTemplate?: string | undefined;
    surveyPermissions?: SurveyPermissionViewModel[] | undefined;
}

export interface SurveyPermissionViewModel {
    id?: number;
    userId?: string | undefined;
    surveyId?: number;
    permissions?: string[] | undefined;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}